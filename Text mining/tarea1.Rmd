---
title: "Tarea 1"
author: "Diabb Zegpi"
date: "25-12-2021"
output: 
  html_document:
    theme: united
    highlight: kate
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
ragg_png = function(..., res = 500) {
  ragg::agg_png(..., res = res, units = "in")
}

knitr::opts_chunk$set(
  echo = TRUE, 
  class.output = "purple-output",
  dev = "ragg_png", 
  fig.align = "center"
)
```

<style>
  body {
    font-size: 16px;
    background-color: #fff9fa;
  }
  
  pre {
    border: 0px;
  }

  .sourceCode, code {
    font-family: 'Fira Mono';
  }
  
  code {
    background-color: #e5eeeb;
    color: #111;
  }
  
  pre.sourceCode {
    color: #111;
    font-weight: 500;
    background-color: #e5eeeb;
  }
  
  code span.fu {
    color: #0e4747;
    font-weight: 600;
  }
  
  code span.sc {
    color: #ae4d00;
    font-weight: 600;
  }
  
  code span.st {
    color: #ae4d00;
  }
  
  .purple-output{
    background-color: #012626;
    color: #eee;
  }
</style>


Este trabajo consiste en la utilización del chat del grupo de Whatsapp *"Magíster USS"*, grupo que conformamos todos los compañeros del Magíster en Data Science, generación 2020. Cabe aclarar que cuento con el consentimiento de mis compañeros para utilizar estos datos, razón por la que tendré los los resguardos necesarios para no exponer conversaciones privadas o comprometedoras. 

El objetivo del proyecto es utilizar los datos de mensajes del grupo para predecir quién es autor(a) de un mensaje determinado.

Primero que todo, se cargan los paquetes de funciones a utilizar en el análisis.

```{r warning=FALSE, message=FALSE}
# Dependencias
library(tidyverse)
library(tidymodels)
library(here)
library(stringi)
library(lubridate)
tidymodels_prefer()
```

Después, se importa el archivo con extensión *.txt* con los datos de conversaciones del grupo. Estos datos son una lista, en que cada nueva línea se compone por un mensaje nuevo o por un salto de línea dentro dentro de un mensaje. Cada mensaje tiene el formato *6/11/2021 20:34 - Remitente: mensaje*. Este formato no es ideal para el análisis de datos, por esto, se recorre la lista de mensajes y saltos de líneas para formar un dataset con 3 columnas: `sender`, `datetime` y `message`.

```{r warning=FALSE}
text <- read.delim(here("Text Mining", "chat_wsp.txt"), 
                   encoding = "UTF-8",
                   sep = "\n",
                   col.names = "text",
                   skip = 1) %>% 
  as_tibble()


text <- text$text
datetime_regex <- "^\\d{1,2}/\\d{1,2}/\\d{4} \\d{2}:\\d{2}"
j <- 1
sender <- vector("character")
datetime <- vector("character")
message <- vector("character")

for (i in 1:length(text)) {
  if (str_detect(text[i], datetime_regex)) {
    sender[j] <- str_match(text[i], "^.+ - (.+?): ")[,2] 
    datetime[j] <- str_match(text[i], datetime_regex)[,1]
    message[j] <- str_match(text[i], "^.+: (.+)$")[,2]
    j <- j + 1
  } else {
    message[j] <- paste(message[j], text[i], sep = " ")
  }
}

chat <- tibble(
  sender = sender, 
  datetime = datetime,
  message = message
)

head(chat)
```

El largo del dataset es de `r nrow(chat)` mensajes. Ha de notarse que muchos de ellos son contenido multimedia, sean como imágenes, audios o videos. Debido a que el análisis del contenido multimedia está fuera del alcance del proyecto, estos han sido omitidos, por ende, los mensajes de multimedia tienen que ser excluidos.

Otra característica del dataset es la codificación: hay caracteres con tildes y emoticones, los que serán removidos en pos de simplificar el análisis. El costo de esta operación es que el texto perderá interpretabilidad, debido a la remoción de tildes y de la letra *ñ*. 

Como etapas finales de la preparación de datos, el texto se pasa a minúsculas y se quitan todos los caracteres que no sean letras del alfabeto latino. Adicionalmente, para mejorar el poder predictivo de los modelos posteriores, se crean las columnas `hour` y `week_day`.

```{r}
chat_clean <- chat %>% 
  mutate(message = stri_trans_general(message, id = "Latin-ASCII"),
         message = str_replace_all(message, "[^\x01-\x7F]", ""),
         message = str_replace(message, "<Multimedia omitido>", ""),
         message = str_to_lower(message),
         message = str_replace_all(message, "[^a-z]", " "),
         message = str_replace_all(message, "\\s+", " "),
         date = as_date(str_sub(datetime, end = -7L), format = "%d/%m/%Y"),
         hour = as.numeric(str_sub(datetime, start = -5L, end = -4L)),
         week_day = weekdays(date)) %>% 
  select(-datetime) %>% 
  filter(!is.na(message) & str_length(message) > 0)
```

El dataset resultante tiene `ncol(chat_clean)` variables y `nrow(chat_clean)` filas o mensajes. 


```{r}
chat_clean %>% 
  
```






















